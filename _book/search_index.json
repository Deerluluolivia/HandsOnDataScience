[
["index.html", "Hands on Data Science with R 1 Introduction", " Hands on Data Science with R Graham Williams Karthik Thirumalai 1 Introduction Data Science is a forest of skills to learn and master. Hands on Data Science with R is a survival guide to data science using R. This book will teach you the practical skills and best practices of data science - With comprehensive and carefully curated solutions to most data science problems, this book provides you a swiss army knife to cut throught the forest. "],
["strings-manipulation.html", "2 Strings Manipulation", " 2 Strings Manipulation In this module we introduce to tools available in R for handling and processing strings. The required packages for this module include: library(rattle) # The weather dataset. library(stringr) # Pre-eminent package for string handling. "],
["string-concatenation.html", "String Concatenation", " String Concatenation Let us start with the simplest of string operations - concatenation two strings. cat The cat() function concatenates objects and could also print them to screen or to a file. By default it converts even numeric and other complex objects into character type and then concatenates. cat(&quot;hello&quot;,&quot;world&quot;,sep=&quot;\\t&quot;) ## hello world x &lt;- 123 # Using numeric values with cat cat (&quot;hello&quot;,x,sep=&quot;\\t&quot;) ## hello 123 paste Alternatively we can use the paste() function to concatenate and print the values to screen. paste(&quot;hello&quot;,&quot;world&quot;, sep=&quot;\\t&quot;) # Usage paste function ## [1] &quot;hello\\tworld&quot; The major disadvantage of the paste function is that it does not handle null characters effectively. It converts the NULL character as a space instead of treating it appropriately. paste(&#39;hello&#39;,NULL,&#39;world&#39;) ## [1] &quot;hello world&quot; str_c The str_c() function is similar to the paste() function but the default separator is white space and it ignores NULL characters. str_c(&#39;hello&#39;,NULL,&#39;world&#39;) # str_c with null characters ## [1] &quot;helloworld&quot; "],
["string-length.html", "String Length", " String Length nchar The nchar() function in the base package is used to measure the typical length of the string. One major issues is itâ€™s inability to handle factor values robustly. nchar(&#39;hello world&#39;) # nchar functionality ## [1] 11 factor.example = factor(c(1, 1, 0,0), labels = c(&quot;success&quot;, &quot;fail&quot;)) # nchar with factor vector nchar(factor.example) ## Error in nchar(factor.example): &#39;nchar()&#39; requires a character vector str_length Alternatively str_length() package could also be used to measure string lengths. In comparisson the str_length() package handles NA characters more accurately as nchar(NA) returns 2 while str_length() returns NA and also handles factor values appropriately. str_length(&#39;hello world&#39;) # str_length from stringr package ## [1] 11 # Handling factors str_length str_length(factor_example) ## Error in stri_length(string): object &#39;factor_example&#39; not found "],
["case-conversion.html", "Case Conversion", " Case Conversion Often during data transformations strings have to be converted from one case to the other. These simple transformations could be achieved by tolower() and toupper() functions. The casefolding() function could also be used as a wrapper to the two functions. # Conversion to upper case toupper(&#39;string manipulation&#39;) ## [1] &quot;STRING MANIPULATION&quot; # Conversion to lower case tolower(&#39;STRING MANIPULATION&#39;) ## [1] &quot;string manipulation&quot; # Casefold to upper casefold(&#39;string manipulation&#39;,upper=TRUE) ## [1] &quot;STRING MANIPULATION&quot; "],
["substring-operation.html", "Substring Operation", " Substring Operation Finding substrings are one of the most common string manipulation operations. substr The substr() could be used to extract, replace parts of the string. # Exctraction strings substr(&#39;string manipulation&#39;,3,6) ## [1] &quot;ring&quot; # Replacing strings with substr s &lt;- &#39;string manipulation&#39; substr(s,3,6) &lt;- &#39;RING&#39; s ## [1] &quot;stRING manipulation&quot; substring The substring() functions performs the same operations on a character vector. # Extraction from character vectors using substring x &lt;- c(&#39;abcd&#39;,&#39;aabcb&#39;,&#39;babcc&#39;,&#39;cabcd&#39;) substring(x,2,last = 4) ## [1] &quot;bcd&quot; &quot;abc&quot; &quot;abc&quot; &quot;abc&quot; # Replacing in character vector using substring substring(x,2,last=4) &lt;- &#39;AB&#39; x ## [1] &quot;aABd&quot; &quot;aABcb&quot; &quot;bABcc&quot; &quot;cABcd&quot; str_sub The stringr package offers str_sub() which is a equivalent of substring(). The str_sub() function handles negative values even more robustly than the substring() function. y = c(&quot;string&quot;, &quot;manipulation&quot;, &quot;always&quot;, &quot;fascinating&quot;) # substring function using negative indices substring(y,first = -4,last = -1) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; # str_sub handles negative indices str_sub(y , start = -4, end = -1) ## [1] &quot;ring&quot; &quot;tion&quot; &quot;ways&quot; &quot;ting&quot; # String replacement using str_sub str_sub(y,start=-4,end=-1) &lt;- &#39;RING&#39; y ## [1] &quot;stRING&quot; &quot;manipulaRING&quot; &quot;alRING&quot; &quot;fascinaRING&quot; "],
["simple-string-operations.html", "Simple String Operations", " Simple String Operations One of the major challenges of string parsing is handline additional whitespaces in words. Often additional widespaces are present on the left, right or both sides of the word. String Trimming The str_trim function offers an effective way to get rid of these whitespaces. whitespace.vector &lt;- c(&#39; abc&#39;,&#39;def &#39;,&#39; ghi &#39;) # Trimming on left sides str_trim(whitespace.vector,side = &#39;left&#39;) ## [1] &quot;abc&quot; &quot;def &quot; &quot;ghi &quot; # Trimming on right sides str_trim(whitespace.vector,side = &#39;right&#39;) ## [1] &quot; abc&quot; &quot;def&quot; &quot; ghi&quot; # Trimming on both sides str_trim(whitespace.vector,side = &#39;both&#39;) ## [1] &quot;abc&quot; &quot;def&quot; &quot;ghi&quot; String Padding Conversely we could also pad a string with additional characters for a defined width using the str_pad() function. The default padding character is a space. # Left padding str_pad(&#39;abc&#39;,width=7,side=&quot;left&quot;) ## [1] &quot; abc&quot; # Right padding str_pad(&#39;abc&#39;,width=7,side=&quot;right&quot;) ## [1] &quot;abc &quot; # Padding other characters str_pad(&#39;abc&#39;,width=7,side=&quot;both&quot;,pad=&quot;#&quot;) ## [1] &quot;##abc##&quot; String Wrapping Sometimes text have to be manipulated to neat paragraphs of defined width. The str_wrap() function could be used to format the text into defined paragraphs of specific width. some.text = &#39;All the Worlds a stage, All men are merely players&#39; cat(str_wrap(some.text,width=25)) ## All the Worlds a stage, ## All men are merely ## players Extracting Words Let us complete this chapter with the simple word() function which extract words from a sentence. We specify the positions of the word to be extracted from the setence. The default separator value is space. # Extracting the first two words of a character vector some.text &lt;- c(&#39;The quick brown fox&#39;,&#39;jumps on the brown dog&#39;) word(some.text,start = 1,end=2) ## [1] &quot;The quick&quot; &quot;jumps on&quot; # Extracting all but the last word word(some.text,start=1,end=-2) ## [1] &quot;The quick brown&quot; &quot;jumps on the brown&quot; "],
["regular-expressions.html", "Regular Expressions", " Regular Expressions Regular expression is a sequence of characters that describe a patttern to match. The concept was formalized by American mathematician Stephen Cole Kleene. A regular expression pattern can contain a combination of alphanumeric and special characters. Let us take a closer look how these special characters can be used to craft regular expressions in R. Metacharacters Metacharacters are characters that have a special meaning within a regular expression. Unlike other characters that are used to match themselves, metacharacters have a reserved status and cannot be matched explicity. The following table shows a list of metacharacters used in regular expressions. Table 2.1: Metacharacters in Regular Expression Metacharacter Description ^ Matches at the start of the string $ Matches at the end of the string () Define a subexpression to be matched and retrieved later. | Matches the pattern before or pattern after [ ] Matches a single character that is contained within bracket . Matches any single character We shall now see how metacharacters can be used to match different patterns with a few examples. string &lt;- c(&#39;hands&#39;,&#39;data&#39;,&#39;on&#39;,&#39;data$cience&#39;,&#39;handsondata$cience&#39;,&#39;handson&#39;) # Matching occurance of pattern at the begining of the string grep(pattern = &#39;^data&#39;,string,value = T) ## [1] &quot;data&quot; &quot;data$cience&quot; # Matching occurance of pattern at the end of the string grep(pattern = &#39;on$&#39;,string,value = T) ## [1] &quot;on&quot; &quot;handson&quot; # Detecting if the pattern (nd) occurs atleast ones str_detect(pattern = &#39;(nd)+&#39;,string) ## [1] TRUE FALSE FALSE FALSE TRUE TRUE Inorder to match a metacharacter in R, we use \\(\\backslash\\backslash\\) (double backslash) before them. # Matching the metacharacter $ grep(pattern = &#39;\\\\$&#39;,string,value = T) ## [1] &quot;data$cience&quot; &quot;handsondata$cience&quot; Quantifiers Quantifiers are used to match repitition of pattern within a string. The following table shows a list of quantifiers. Table 2.2: Quantifiers in Regular Expression Quantifier Description * The preceeding item is matched 0 or more times + The preceeding item is matched 1 or more times ? The preceeding item is matched at most 1 times. {n} The preceeding item is matched n times. {n,} The preceeding item is matched atleast n times. Let us see some examples of quantifiers in practice. strings &lt;- c(&#39;aaab&#39;,&#39;abb&#39;,&#39;bc&#39;,&#39;abbcd&#39;,&#39;bbbc&#39;,&#39;abab&#39;,&#39;caa&#39;) #* Strings containing data atleast 0 times grep(pattern = &#39;ab*b&#39;,strings,value = T) ## [1] &quot;aaab&quot; &quot;abb&quot; &quot;abbcd&quot; &quot;abab&quot; #? Strings containing the pattern atmost ones grep(pattern = &#39;abbc?&#39;,strings,value = T) ## [1] &quot;abb&quot; &quot;abbcd&quot; # Atleast two occurances grep(pattern = &#39;b{2,}?&#39;,strings,value = T) ## [1] &quot;abb&quot; &quot;abbcd&quot; &quot;bbbc&quot; Character classes A character class is a set that characterises a category of characters. They are enclosed within [] and they match one of the mentioned characters in the set. For example the character class [0-9] matches the first digit occuring in the string. Below are a set of character classes. Table 2.3: Character Class Character.Class Description [0-9] Digits [a-z] Lower-case letters [A-Z] Upper-case letters [a-zA-Z] Alphabetic characters [^a-zA-Z] Non-alphabetic characters [a-zA-Z0-9] Alphanumeric characters [] Space characters [!,:;`)}@-]$*+.?[^{|(\\\\#%&amp;~_/&lt;=&gt;'] Punctuation characters Let us see some simple examples of using character classes in regular expressions. string &lt;- c(&#39;abc12&#39;,&#39;@#$&#39;,&#39;345&#39;,&#39;ABcd&#39;) # Matching strings containing digits grep(pattern = &#39;[0-9]+&#39;,string,value = T) ## [1] &quot;abc12&quot; &quot;345&quot; # Matching strings containing Capital letters grep(pattern = &#39;[A-Z]+&#39;,string,value = T) ## [1] &quot;ABcd&quot; # Matching strings not containing special characters grep(pattern = &#39;[^@#$]+&#39;,string,value = T) ## [1] &quot;abc12&quot; &quot;345&quot; &quot;ABcd&quot; Alternatively R allows the use of POSIX character classes which are represented within [[]] (double braces). # Matching alphanumeric characters grep(pattern = &#39;[[:alpha:]]&#39;,string,value = T) ## [1] &quot;abc12&quot; &quot;ABcd&quot; # Matching upper case characters grep(pattern = &#39;[[:upper:]]&#39;,string,value = T) ## [1] &quot;ABcd&quot; Functions in R to Support Regular Expressions R has a great array of functions that support regular expressions. The following is a list of functions from the base and stringr package that support regular expressions. Table 2.4: Functions Supporting Regular Expressions in R Function Description grep() Returns index of elements that matched grepl() Returns boolean values indicating if a pattern exist in the string (TRUE &amp; FALSE) regexpr() Returns the first match of the pattern in string gregexpr() Returns all matches of pattern in string regexec() Combines results of regexpr() and gregexpr() sub() Replaces the first match of pattern with replacement gsub() Replaces all matches of pattern with replacement strsplit() Split string in to vector according to pattern match str_detect() Detect a presence or absence of a pattern in a string str_extract() Extracts first occurance of pattern in string. str_extract_all() Extracts all occurance of pattern in string. str_match() Extract first matched group from a string str_match_all() Extract all matched groups from a string str_locate() Locate the position of the frst occurence of a pattern in a string str_locate_all() Locate the position of all occurences of a pattern in a string str_replace() Returns the first match of the pattern in string str_replace_all() Returns all matches of pattern in string str_split() Split up a string into a variable number of pieces str_split_fixed() Split up a string into a fixed number of pieces -->"],
["maps-and-spatial-visualization.html", "3 Maps and Spatial Visualization", " 3 Maps and Spatial Visualization Spatial data is central to many of our tasks as Data Scientists. Identifying patterns, correlations and relationships between those patterns delivers opportunities for delivering new services. Imagine predicting common routes for travellers this morning, and dynamically routing public transport to meet those needs. Fundamental to the Data Scientist is the ability to process, visualize and then model spatial data. Done right maps can be a very effective communications tool. Numerous R packages work together to bring us a sophisticated mapping and spatial analysis capability. library(ggplot2) # Plotting maps. library(maps) # Map data. library(scales) # For transperency Functions: alpha() comma() library(maptools) # For shapefiles library(dismo) # Obtaining gis data library(broom) # For conversion functions: tidy() library(rgdal) # For shapefiles library(dplyr) # For sample function library(OpenStreetMap) # OSM maps library(ggmap) # Google maps library(leaflet) # Interactive Viz knitr::opts_chunk$set(cache=TRUE) "],
["geocodes.html", "Geocodes", " Geocodes One of the fundamental things about spatial data and mapping is the geographic coordinate system used to uniquely identify locations. We use longitude (x axis, abbreviated lon) and latitude (y axis, abbreviated lat) for locations on our planet. The longitude is the angle from the meridian through Greenwich and the latitude is the angle from the equator. We can use street addresses and locations. Here are a few examples. geocode(&quot;Singapore&quot;) ## lon lat ## 1 103.8198 1.352083 geocode(&quot;11 Bunda Street, Canberra&quot;) ## lon lat ## 1 149.1312 -35.27757 geocode(&quot;Raffles Place&quot;,output=&quot;more&quot;) ## lon lat type loctype address north ## 1 103.8515 1.283933 establishment approximate raffles place 1.285282 ## south east west establishment neighborhood locality country ## 1 1.282584 103.8528 103.8501 Raffles Place Downtown Core Singapore For later use we will save some of our locations. (cityhall &lt;- as.numeric(geocode(&quot;City Hall,Singapore&quot;))) ## [1] 103.852423 1.293149 (raffles &lt;- as.numeric(geocode(&quot;Raffles Place&quot;))) ## [1] 103.851455 1.283933 (sentosa &lt;- as.numeric(geocode(&quot;Sentosa&quot;))) ## [1] 103.830321 1.249404 "],
["world-map.html", "World Map", " World Map The data for plotting the World map comes from the maps (Brownrigg, 2014) package. We load the vector data for plotting a world map using map_data(). ds &lt;- map_data(&quot;world&quot;) head(ds) ## long lat group order region subregion ## 1 -69.89912 12.45200 1 1 Aruba &lt;NA&gt; ## 2 -69.89571 12.42300 1 2 Aruba &lt;NA&gt; ## 3 -69.94219 12.43853 1 3 Aruba &lt;NA&gt; ## 4 -70.00415 12.50049 1 4 Aruba &lt;NA&gt; ## 5 -70.06612 12.54697 1 5 Aruba &lt;NA&gt; ## 6 -70.05088 12.59707 1 6 Aruba &lt;NA&gt; It is quite simple to plot the world map using ggplot2 (Wickham and Chang, 2014). p &lt;- ggplot(ds, aes(x=long,y=lat,group=group)) + geom_polygon() p Let us add some colour based on regions. Now there are many regions, so for the same of aesthecity we will turn off the legend. p &lt;- ggplot(ds, aes(x=long, y=lat, group=group, fill=region)) + geom_polygon() + theme(legend.position=&quot;none&quot;) "],
["understanding-spatial-data.html", "Understanding Spatial Data", " Understanding Spatial Data Spatial data involves a combination of information about locations and geometric features related that best describe the location. The most commonly used formats to store spatial information are Raster and Vector. A Raster format is a type of digital image represented by grids which can be reduced and enlarged. They are made up of a matrix of pixels with each pixel representing an area within the spatial object. A Vector format consists of geometric shapes organized in the form of shapefiles. A shapefile consist of three files under the extensions .shp, .shx and .dbf which contain the features, indices of shapes and attributes respectively. Plotting Raster Data We shall use the getData function in the dismo package to obtain altitude data of Australia and plot them. aust &lt;- getData(&#39;alt&#39;, country=&#39;Australia&#39;, mask=TRUE) ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files plot(aust) ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files Plotting Shapefiles Let us visualize the streets and places of Singapore. We can obtain the data from data.gov.sg . We shall project it on top of a base map obtained from OpenStreetMap. shpfile &lt;- readOGR(dsn=&#39;data/street-and-places/&#39;,&#39;StreetsandPlaces&#39;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;data/street-and-places/&quot;, layer: &quot;StreetsandPlaces&quot; ## with 369 features ## It has 18 fields ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files head(coordinates(shpfile),5) ## coords.x1 coords.x2 ## [1,] 28640.40 29320.77 ## [2,] 29429.83 28548.69 ## [3,] 29224.01 28360.38 ## [4,] 29827.20 29664.26 ## [5,] 28451.00 29451.78 It is observed that the projection system is different than the base map. So we shall transform the projection in to Web Mercator. crsobj &lt;- CRS(&quot;+proj=longlat +datum=WGS84&quot;) # Web Mercator projection system ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files shpfile.t &lt;- spTransform(shpfile,crsobj) # Applying projection transformation ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files df &lt;- as.data.frame(coordinates(shpfile.t)) # Converting to a data frame head(df,5) ## coords.x1 coords.x2 ## 1 103.8391 1.281441 ## 2 103.8462 1.274459 ## 3 103.8443 1.272756 ## 4 103.8497 1.284547 ## 5 103.8374 1.282626 Now it looks fine to be projected on top of the base map. sgmap &lt;- get_map(location=&quot;Singapore&quot;, zoom=11, maptype=&quot;roadmap&quot;, source=&quot;osm&quot;) # Using Osm base map of Singapore ## Source : https://maps.googleapis.com/maps/api/staticmap?center=Singapore&amp;zoom=11&amp;size=640x640&amp;scale=2&amp;maptype=terrain ## Source : https://maps.googleapis.com/maps/api/geocode/json?address=Singapore p &lt;- ggmap(sgmap) + geom_point(data = df, aes(x = coords.x1, y = coords.x2), color = &#39;orange&#39;,size = 1) p "],
["annotating-location-on-a-map.html", "Annotating Location on a Map", " Annotating Location on a Map We shall plot the location of Sentosa and annotate it with a location landmark and text. addr &lt;- &#39;Sentosa&#39; loc &lt;- as.numeric(geocode(addr)) map &lt;- get_map(loc,zoom = 15, maptype = &#39;satellite&#39;,source = &#39;osm&#39;) lbl &lt;- data.frame(lon = loc[1], lat = loc[2], text = addr) p &lt;- ggmap(map) p &lt;- p + geom_text(data = lbl, aes(x = lon, y = lat, label = text),colour = &#39;blue&#39;, vjust = 1.5) p &lt;- p + geom_point(data = lbl, aes(x = lon, y = lat),colour = &#39;red&#39;, size = 3) p "],
["plotting-polygons-and-heatmaps.html", "Plotting Polygons and HeatMaps", " Plotting Polygons and HeatMaps Let us plot the male population from the subzone male population dataset of Singapore. We shall first plot the spatial boundaries of the polygon and then overlay the gradients of male population over it. sg.popul.spdf &lt;- readOGR(dsn = &#39;data/subzone-age-male-2016&#39;, &#39;SUBZONE_AGE_MALE_2016&#39;,verbose = F) # Transforming to WSG1984 sg.popul.spdf &lt;- spTransform(sg.popul.spdf, CRSobj = crsobj) # Converting spatialPolygon to DataFrame sg.df &lt;- tidy(sg.popul.spdf) sg.df$id &lt;- as.integer(sg.df$id) # Creating a dataframe containing the Population data sg.data &lt;- data.frame(Population = cut_number(sg.popul.spdf$TOTAL,3), ZONE = sg.popul.spdf$SUBZONE_N, id = sg.popul.spdf$OBJECTID) # Merging the two datasets sg.df &lt;- merge(sg.df,sg.data,by = &#39;id&#39;) p &lt;- ggmap(sgmap) pop.plt &lt;- p + geom_polygon(data = sg.df, aes(x= long, y = lat, fill = Population)) pop.plt &lt;- pop.plt + theme(line = element_blank(), axis.title = element_blank(), axis.text = element_blank(), title = element_text(hjust = 0.5)) + scale_fill_brewer(palette = 1,type = &#39;seq&#39;) + ggtitle(&#39;Male Population Singapore 2016&#39;) pop.plt "],
["interactive-maps-with-leaflet.html", "Interactive Maps with Leaflet", " Interactive Maps with Leaflet Earlier we saw a static visualization of places in Singapore now we can explore an interactive version of the same using leaflet. library(leaflet) smpl &lt;- sample_n(df, size = 30) leaflet() %&gt;% addTiles() %&gt;% addMarkers(data = smpl,lng = smpl$coords.x1, lat = smpl$coords.x2) -->"]
]
