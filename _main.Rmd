--- 
title: "Hands on Data Science with R"
author: ["Graham Williams", "Karthik Thirumalai"]
knit: "bookdown::render_book"
site: bookdown::bookdown_site
documentclass: book
link-citations: yes
cover-image: graphics/book-cover-A4.png
description: "Hands on Data Science with R is a practical and hands on guide to data science with R" 
---


# Introduction

Data Science is a forest of skills to learn and master. Hands on Data Science with R is a survival guide to data science using R. This book will teach you the practical skills and best practices of data science - With comprehensive and carefully curated solutions to most data science problems, this book provides you a swiss army knife to cut throught the forest.

```{r echo=FALSE, out.width="33%",fig.align='center'}
knitr::include_graphics("graphics/book-cover-A4.png")
```


<!--chapter:end:index.Rmd-->

---
knit: "bookdown::preview_chapter"
---

# Strings Manipulation

In this module we introduce to tools available in R for handling and processing strings.
The required packages for this module include:

```{r results='hide',message=FALSE}
library(rattle) # The weather dataset.
library(stringr) # Pre-eminent package for string handling.
```

## String Concatenation

Let us start with the simplest of string operations - concatenation two strings. 

### cat

The **cat()** function concatenates objects and could also print them to screen or to a file. By default it converts even numeric and other complex objects into character type and then concatenates.

```{r,eval=TRUE}
cat("hello","world",sep="\t")

x <- 123 #Using numeric values with cat
cat ("hello",x,sep="\t")
```

###paste

Alternatively we can use the **paste()** function to concatenate and print the values to screen. 
```{r}
paste("hello","world", sep="\t") #usage paste function
```

The major disadvantage of the paste function is that it does not handle null characters effectively. It converts the NULL character as a space instead of treating it appropriately.

```{r}
paste('hello',NULL,'world')
```

###str_c
The **str_c()** function is similar to the paste() function but the default separator is white space and it ignores NULL characters. 

```{r}
str_c('hello',NULL,'world') # str_c with null characters
```

## String Length 

###nchar
The **nchar()** function in the base package is used to measure the typical length of the string. One major issues is it's inability to handle factor values robustly.

```{r,error=T}
nchar('hello world') #nchar functionality

factor_example = factor(c(1, 1, 0,0), labels = c("success", "fail"))
#nchar with factor vector
nchar(factor_example)

```

###str_length
Alternatively **str_length()** package could also be used to measure string lengths. In comparisson the str\_length() package handles NA characters more accurately as nchar(NA) returns 2 while str\_length() returns NA and also handles factor values appropriately.

```{r,error=T}

str_length('hello world') #str_length from stringr package

#Handling factors str_length
str_length(factor_example)
```

## Case Conversion

Often during data transformations strings have to be converted from one case to the other. These simple transformations could be achieved by **tolower()** and **toupper()** functions. The **casefolding()** function could also be used as a wrapper to the two functions.

```{r,message=F}

#Conversion to upper case
toupper('string manipulation')

#Conversion to lower case
tolower('STRING MANIPULATION')

#casefold to upper
casefold('string manipulation',upper=TRUE)
```

## Substring Operation 

Finding substrings are one of the most common string manipulation operations.

###**substr**
The **substr()** could be used to extract, replace parts of the string. 
```{r}

#Exctraction strings
substr('string manipulation',3,6)

#Replacing strings with substr
s <- 'string manipulation'
substr(s,3,6) <- 'RING'
s
```

###**substring**
The **substring()** functions performs the same operations on a character vector. 

```{r}
#Extraction from character vectors using substring
x <- c('abcd','aabcb','babcc','cabcd')
substring(x,2,last = 4)

#Replacing in character vector using substring
substring(x,2,last=4) <- 'AB'
x
```

###str_sub
The stringr package offers **str_sub()** which is a equivalent of substring(). The str\_sub() function handles negative values even more robustly than the substring() function.

```{r}
y = c("string", "manipulation", "always", "fascinating")

#substring function using negative indices
substring(y,first = -4,last = -1)
# str_sub handles negative indices
str_sub(y , start = -4, end = -1)

#String replacement using str_sub
str_sub(y,start=-4,end=-1) <- 'RING'
y
```

## Simple String Operations

One of the major challenges of string parsing is handline additional whitespaces in words. Often additional widespaces are present on the left, right or both sides of the word. 

###String Trimming

The **str_trim** function offers an effective way to get rid of these whitespaces.

```{r}
whitespace.vector <- c('  abc','def   ','     ghi       ')
#trimming on left sides
str_trim(whitespace.vector,side = 'left')
#trimming on right sides
str_trim(whitespace.vector,side = 'right')
#trimming on both sides
str_trim(whitespace.vector,side = 'both')
```

### String Padding

Conversely we could also pad a string with additional characters for a defined width using the **str_pad()**
function. The default padding character is a space.

```{r}
#Left padding
str_pad('abc',width=7,side="left")

#Right padding
str_pad('abc',width=7,side="right")

#Padding other characters
str_pad('abc',width=7,side="both",pad="#")
```

### String Wrapping

Sometimes text have to be manipulated to neat paragraphs of defined width. The **str_wrap()** function could be used to format the text into defined paragraphs of specific width.

```{r}

some_text = 'All the Worlds a stage, All men are merely players'
cat(str_wrap(some_text,width=25))
```

### Extracting Words

Let us complete this chapter with the simple **word()** function which extract words from a sentence. We specify the positions of the word to be extracted from the setence. The default separator value is space.

```{r}
#Extracting the first two words of a character vector
some.text <- c('The quick brown fox','jumps on the brown dog')
word(some.text,start = 1,end=2)
#extracting all but the last word
word(some.text,start=1,end=-2)
```




<!--chapter:end:01.StringsO.Rmd-->

---
knit: "bookdown::preview_chapter"
---

# Parallel Execution

R supports several levels of parallel execution, starting with executing code on multiple cores,
and going up to executing code in massively parallel Hadoop platforms.  Since R Version 2.14.0
parallel has provided support for parallel computation through forking (c.f.multicore) and sockets
(c.f.snow).

To illustrate parallel computation we will build rpart decision trees in parallel.
The required packages for this module include:

```{r}
library(parallel)
library(snow)
library(rpart)
```

## Getting Started
Let us use would be using the Weather data set from the rattle package in this chapter. Using the dataset we would be predicting the amount of rainfall for the next day. 

```{r,message=FALSE}
library(rattle)
ds <- weatherAUS
target <- "RainTomorrow"              #Defining the target variable
risk <- "RISK_MM"                     #Defining the risk
ds[target] <- as.factor(ds[[target]]) #Converting the target to factor
```

<h4> Data Preparation </h4>

```{r}
vars <- colnames(ds)
ignore <- vars[c(1, 2, if (exists("risk")) which(risk==vars))] #Ignoring the risk
vars <- setdiff(vars, ignore)
inputs <- setdiff(vars, target)                                #Defining the input variables
form <- paste(target,paste(inputs,                             #Defining the formula
                  collapse = " + "),sep = " ~ ")

nobs <- nrow(ds)                                               #Number of records
train <- sample(nobs, 0.7*nobs)                                #Sampling for train dataset
test <- setdiff(seq_len(nobs), train)                          #Test dataset
```

## Begin Parallel

The parallel package provides functions to distribute the computation across multiple cores and servers.
We first determine the number of cores available on the computer we are processing our data on

```{r}
cores <- detectCores()
cores
```

For the purpose of model building, we would be using wsrpart() function to build decision trees based on random subset of the data. 

In order to build models in parallel we will be using the function mcparallel(). This command forks (can be used only on Windows) the current process to build a tree 

```{r}
jobs <- lapply(1:cores,
               function(x) mcparallel(wsrpart(form,ds[train,vars], ntrees=1),
                                              name=sprintf("dt%02d",x)))
```

<h4> Collect Results </h4>

```{r}
system.time(model <- mccollect(jobs,wait=TRUE))
```
The decision tree will be available in the resulting list.
```{r}
length(model)
model[[1]][[1]]
```

## Parallel Processes Through Local Sockets

Before we proceed to run parallel processes over a network of workers (remote servers) we will
do the same, but have a single node cluster (the current server).  We use makeCluster() from
parallel to do this.

We begin with a simple example by creating a cluster of as many nodes as there are cores on the localhost.
```{r,error=T}
cl <- makeCluster(getOption("cl.cores", 2))
cl
```
Now we ask each node of the cluster to do something. In this case we get the addition function
with the additional argument 3.  The 1:2 are the arguments passed to each node, so that node 1
gets 1 and node 2 gets 2.
```{r,error=T}
clusterApply(cl,1:2,get("+"),3)
```



<!--chapter:end:02.ParallelO.Rmd-->

