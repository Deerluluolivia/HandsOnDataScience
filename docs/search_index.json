[
["index.html", "Hands on Data Science with R 1 Introduction", " Hands on Data Science with R 1 Introduction Data Science is a forest of skills to learn and master. Hands on Data Science with R is a survival guide to data science using R. This book will teach you the practical skills and best practices of data science - With comprehensive and carefully curated solutions to most data science problems, this book provides you a swiss army knife to cut throught the forest. "],
["strings-manipulation.html", "2 Strings Manipulation", " 2 Strings Manipulation In this module we introduce to tools available in R for handling and processing strings. The required packages for this module include: library(rattle) # The weather dataset. library(stringr) # Pre-eminent package for string handling. "],
["string-concatenation.html", "String Concatenation", " String Concatenation Let us start with the simplest of string operations - concatenation two strings. cat The cat() function concatenates objects and could also print them to screen or to a file. By default it converts even numeric and other complex objects into character type and then concatenates. cat(&quot;hello&quot;, &quot;world&quot;, sep=&quot;\\t&quot;) ## hello world # Using numeric values with cat(). x &lt;- 123 cat (&quot;hello&quot;, x, sep=&quot;\\t&quot;) ## hello 123 paste Alternatively we can use the paste() function to concatenate and print the values to screen. paste(&quot;hello&quot;, &quot;world&quot;, sep=&quot;\\t&quot;) ## [1] &quot;hello\\tworld&quot; The major disadvantage of the paste function is that it does not handle null characters effectively. It converts the NULL character as a space instead of treating it appropriately. WHAT IS APPROPRIATE? paste(&#39;hello&#39;, NULL, &#39;world&#39;) ## [1] &quot;hello world&quot; str_c The str_c() function is similar to the paste() function but the default separator is white space and it ignores NULL characters. str_c(&#39;hello&#39;, NULL, &#39;world&#39;) # Using str_c with null characters. ## [1] &quot;helloworld&quot; "],
["string-length.html", "String Length", " String Length nchar The nchar() function in the base package is used to measure the typical length of the string. One major issues is itâ€™s inability to handle factor values robustly. nchar(&#39;hello world&#39;) # Usage of the nchar function. ## [1] 11 factor.Example &lt;- factor(c(1, 1, 0, 0), labels=c(&quot;success&quot;, &quot;fail&quot;)) nchar(factor.Example) # Using nchar function with factors. ## Error in nchar(factor.Example): &#39;nchar()&#39; requires a character vector str_length Alternatively str_length() package could also be used to measure string lengths. In comparisson the str_length() package handles NA characters more accurately as nchar(NA) returns 2 while str_length() returns NA and also handles factor values appropriately. str_length(&#39;hello world&#39;) # Usage of the str_length function. ## [1] 11 str_length(factor_example) # Using str_length with factor variables. ## Error in stri_length(string): object &#39;factor_example&#39; not found "],
["case-conversion.html", "Case Conversion", " Case Conversion Often during data transformations strings have to be converted from one case to the other. These simple transformations could be achieved by tolower() and toupper() functions. The casefolding() function could also be used as a wrapper to the two functions. toupper(&#39;string manipulation&#39;) # Converting text to upper case. ## [1] &quot;STRING MANIPULATION&quot; tolower(&#39;STRING MANIPULATION&#39;) # Converting text to lower case. ## [1] &quot;string manipulation&quot; casefold(&#39;string manipulation&#39;, upper=TRUE) # Usage of the casefold function. ## [1] &quot;STRING MANIPULATION&quot; "],
["substring-operation.html", "Substring Operation", " Substring Operation Finding substrings are one of the most common string manipulation operations. substr The substr() could be used to extract, replace parts of the string. substr(&#39;string manipulation&#39;, 3, 6) # Usage of substr function. ## [1] &quot;ring&quot; s &lt;- &#39;string manipulation&#39; substr(s, 3, 6) &lt;- &#39;RING&#39; # Replacing strings with the substr function. s ## [1] &quot;stRING manipulation&quot; substring The substring() functions performs the same operations on a character vector. x &lt;- c(&#39;abcd&#39;, &#39;aabcb&#39;, &#39;babcc&#39;, &#39;cabcd&#39;) # Extracting characters using the substring function substring(x, 2, last=4) ## [1] &quot;bcd&quot; &quot;abc&quot; &quot;abc&quot; &quot;abc&quot; substring(x, 2, last=4) &lt;- &#39;AB&#39; # Replacing strings with the substring function. x ## [1] &quot;aABd&quot; &quot;aABcb&quot; &quot;bABcc&quot; &quot;cABcd&quot; str_sub The stringr package offers str_sub() which is a equivalent of substring(). The str_sub() function handles negative values even more robustly than the substring() function. y &lt;- c(&quot;string&quot;, &quot;manipulation&quot;, &quot;always&quot;, &quot;fascinating&quot;) substring(y, first=-4, last=-1) # Using the substring functions with negative indices. ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; str_sub(y , start=-4, end=-1) # Using the str_sub function to handle negative indices. ## [1] &quot;ring&quot; &quot;tion&quot; &quot;ways&quot; &quot;ting&quot; str_sub(y, start=-4, end=-1) &lt;- &#39;RING&#39; # String replacement using the str_sub function. y ## [1] &quot;stRING&quot; &quot;manipulaRING&quot; &quot;alRING&quot; &quot;fascinaRING&quot; "],
["simple-string-operations.html", "Simple String Operations", " Simple String Operations One of the major challenges of string parsing is handline additional whitespaces in words. Often additional widespaces are present on the left, right or both sides of the word. String Trimming The str_trim function offers an effective way to get rid of these whitespaces. whitespace.vector &lt;- c(&#39; abc&#39;, &#39;def &#39;, &#39; ghi &#39;) str_trim(whitespace.vector, side=&#39;left&#39;) # Trimming white spaces on the left side of the string. ## [1] &quot;abc&quot; &quot;def &quot; &quot;ghi &quot; str_trim(whitespace.vector, side=&#39;right&#39;) # Trimming white spaces on the right side of the string. ## [1] &quot; abc&quot; &quot;def&quot; &quot; ghi&quot; str_trim(whitespace.vector, side=&#39;both&#39;) # Trimming white spaces on both sides of the string. ## [1] &quot;abc&quot; &quot;def&quot; &quot;ghi&quot; String Padding Conversely we could also pad a string with additional characters for a defined width using the str_pad() function. The default padding character is a space. str_pad(&#39;abc&#39;, width=7, side=&quot;left&quot;) # Padding characters to the left side of the string. ## [1] &quot; abc&quot; str_pad(&#39;abc&#39;, width=7, side=&quot;right&quot;) # Padding characters to the right side of the string. ## [1] &quot;abc &quot; str_pad(&#39;abc&#39;, width=7, side=&quot;both&quot;, pad=&quot;#&quot;) # Padding other characters to both sides of a string. ## [1] &quot;##abc##&quot; String Wrapping Sometimes text have to be manipulated to neat paragraphs of defined width. The str_wrap() function could be used to format the text into defined paragraphs of specific width. some.text &lt;- &#39;All the Worlds a stage, All men are merely players&#39; cat(str_wrap(some.text, width=25)) # Usage of the str_wrap function. ## All the Worlds a stage, ## All men are merely ## players Extracting Words Let us complete this chapter with the simple word() function which extract words from a sentence. We specify the positions of the word to be extracted from the setence. The default separator value is space. some.text &lt;- c(&#39;The quick brown fox&#39;, &#39;jumps on the brown dog&#39;) # Extracting the first two words of a character vector. word(some.text, start=1, end=2) ## [1] &quot;The quick&quot; &quot;jumps on&quot; word(some.text, start=1, end=-2) # Extracting all but the last word from a character vector. ## [1] &quot;The quick brown&quot; &quot;jumps on the brown&quot; "],
["regular-expressions.html", "Regular Expressions", " Regular Expressions Regular expression is a sequence of characters that describe a patttern to match. The concept was formalized by American mathematician Stephen Cole Kleene. A regular expression pattern can contain a combination of alphanumeric and special characters. Let us take a closer look how these special characters can be used to craft regular expressions in R. Metacharacters Metacharacters are characters that have a special meaning within a regular expression. Unlike other characters that are used to match themselves, metacharacters have a reserved status and cannot be matched explicity. The following table shows a list of metacharacters used in regular expressions. (#tab:Table 1: metacharacters)Metacharacters in Regular Expression Metacharacter Description ^ Matches at the start of the string $ Matches at the end of the string () Define a subexpression to be matched and retrieved later. | Matches the pattern before or pattern after [ ] Matches a single character that is contained within bracket . Matches any single character We shall now see how metacharacters can be used to match different patterns with a few examples. string &lt;- c(&#39;hands&#39;, &#39;data&#39;, &#39;on&#39;, &#39;data$cience&#39;, &#39;handsondata$cience&#39;, &#39;handson&#39;) grep(pattern=&#39;^data&#39;, string, value=TRUE) # Matching the occurance of pattern at the begining of the string. ## [1] &quot;data&quot; &quot;data$cience&quot; grep(pattern=&#39;on$&#39;, string, value=TRUE) # Matching occurance of pattern at the end of the string. ## [1] &quot;on&quot; &quot;handson&quot; str_detect(pattern=&#39;(nd)+&#39;, string) # Detecting if the pattern (nd) occurs atleast ones. ## [1] TRUE FALSE FALSE FALSE TRUE TRUE Inorder to match a metacharacter in R, we use \\(\\backslash\\backslash\\) (double backslash) before them. grep(pattern=&#39;\\\\$&#39;, string, value=TRUE) # Matching the metacharacter $ ## [1] &quot;data$cience&quot; &quot;handsondata$cience&quot; Quantifiers Quantifiers are used to match repitition of pattern within a string. The following table shows a list of quantifiers. (#tab:Table 1: quantifiers)Quantifiers in Regular Expression Quantifier Description * The preceeding item is matched 0 or more times + The preceeding item is matched 1 or more times ? The preceeding item is matched at most 1 times. {n} The preceeding item is matched n times. {n,} The preceeding item is matched atleast n times. Let us see some examples of quantifiers in practice. strings &lt;- c(&#39;aaab&#39;, &#39;abb&#39;, &#39;bc&#39;, &#39;abbcd&#39;, &#39;bbbc&#39;, &#39;abab&#39;, &#39;caa&#39;) grep(pattern=&#39;ab*b&#39;, strings, value=TRUE) # Matching strings containining a pattern atleast 0 times. ## [1] &quot;aaab&quot; &quot;abb&quot; &quot;abbcd&quot; &quot;abab&quot; grep(pattern=&#39;abbc?&#39;, strings, value=TRUE) # Matching strings containing the pattern atmost ones. ## [1] &quot;abb&quot; &quot;abbcd&quot; grep(pattern=&#39;b{2,}?&#39;, strings, value=TRUE) # Matching strings containing the pattern atleast 2 times. ## [1] &quot;abb&quot; &quot;abbcd&quot; &quot;bbbc&quot; Character classes A character class is a set that characterises a category of characters. They are enclosed within [] and they match one of the mentioned characters in the set. For example the character class [0-9] matches the first digit occuring in the string. Below are a set of character classes. (#tab:Table 3: Character class)Character Class Character.Class Description [0-9] Digits [a-z] Lower-case letters [A-Z] Upper-case letters [a-zA-Z] Alphabetic characters [^a-zA-Z] Non-alphabetic characters [a-zA-Z0-9] Alphanumeric characters [] Space characters [!,:;`)}@-]$*+.?[^{|(\\\\#%&amp;~_/&lt;=&gt;'] Punctuation characters Let us see some simple examples of using character classes in regular expressions. string &lt;- c(&#39;abc12&#39;, &#39;@#$&#39;, &#39;345&#39;, &#39;ABcd&#39;) grep(pattern=&#39;[0-9]+&#39;, string, value=TRUE) # Matching strings that have digits. ## [1] &quot;abc12&quot; &quot;345&quot; grep(pattern=&#39;[A-Z]+&#39;, string, value=TRUE)# Matching strings that have capital letters. ## [1] &quot;ABcd&quot; grep(pattern=&#39;[^@#$]+&#39;, string, value=TRUE) # Matching strings not do not have special characters. ## [1] &quot;abc12&quot; &quot;345&quot; &quot;ABcd&quot; Alternatively R allows the use of POSIX character classes which are represented within [[]] (double braces). grep(pattern=&#39;[[:alpha:]]&#39;, string, value=TRUE) # Matching alpha numeric characters. ## [1] &quot;abc12&quot; &quot;ABcd&quot; grep(pattern=&#39;[[:upper:]]&#39;, string, value=TRUE) # Matching upper case characters. ## [1] &quot;ABcd&quot; Functions in R to Support Regular Expressions R has a great array of functions that support regular expressions. The following is a list of functions from the base and stringr package that support regular expressions. (#tab:Table 4: Functions supporting regular expressions)Functions Supporting Regular Expressions in R Function Description grep() Returns index of elements that matched grepl() Returns boolean values indicating if a pattern exist in the string (TRUE &amp; FALSE) regexpr() Returns the first match of the pattern in string gregexpr() Returns all matches of pattern in string regexec() Combines results of regexpr() and gregexpr() sub() Replaces the first match of pattern with replacement gsub() Replaces all matches of pattern with replacement strsplit() Split string in to vector according to pattern match str_detect() Detect a presence or absence of a pattern in a string str_extract() Extracts first occurance of pattern in string. str_extract_all() Extracts all occurance of pattern in string. str_match() Extract first matched group from a string str_match_all() Extract all matched groups from a string str_locate() Locate the position of the frst occurence of a pattern in a string str_locate_all() Locate the position of all occurences of a pattern in a string str_replace() Returns the first match of the pattern in string str_replace_all() Returns all matches of pattern in string str_split() Split up a string into a variable number of pieces str_split_fixed() Split up a string into a fixed number of pieces -->"],
["maps-and-spatial-visualization.html", "3 Maps and Spatial Visualization", " 3 Maps and Spatial Visualization Spatial data is central to many of our tasks as Data Scientists. Identifying patterns, correlations and relationships between those patterns delivers opportunities for delivering new services. Imagine predicting common routes for travellers this morning, and dynamically routing public transport to meet those needs. Fundamental to the Data Scientist is the ability to process, visualize and then model spatial data. Done right maps can be a very effective communications tool. Numerous R packages work together to bring us a sophisticated mapping and spatial analysis capability. library(ggplot2) # Plotting maps. library(maps) # Map data. library(scales) # For transperency Functions: alpha() comma() library(maptools) # For shapefiles library(dismo) # Obtaining gis data library(broom) # For conversion functions: tidy() library(rgdal) # For shapefiles library(dplyr) # For sample function library(OpenStreetMap) # OSM maps library(ggmap) # Google maps library(leaflet) # Interactive Maps library(shiny) # Interactive Viz library(magrittr) # XXXX. "],
["geocodes.html", "Geocodes", " Geocodes One of the fundamental things about spatial data and mapping is the geographic coordinate system used to uniquely identify locations. We use longitude (x axis, abbreviated lon) and latitude (y axis, abbreviated lat) for locations on our planet. The longitude is the angle from the meridian through Greenwich and the latitude is the angle from the equator. We can use street addresses and locations. Here are a few examples. geocode(&quot;Singapore&quot;) ## lon lat ## 1 103.8198 1.352083 geocode(&quot;11 Bunda Street, Canberra&quot;) ## lon lat ## 1 149.1319 -35.27705 geocode(&quot;Raffles Place&quot;, output=&quot;more&quot;) ## lon lat type loctype address north ## 1 103.8513 1.2841 route geometric_center raffles place, singapore 1.285651 ## south east west route neighborhood locality country ## 1 1.282702 103.8527 103.85 Raffles Place Downtown Core Singapore Singapore For later use we will save some of our locations. cityhall &lt;- as.numeric(geocode(&quot;City Hall, Singapore&quot;)) %T&gt;% print() ## [1] 103.852460 1.293186 raffles &lt;- as.numeric(geocode(&quot;Raffles Place&quot;)) %T&gt;% print() ## [1] 103.8513 1.2841 sentosa &lt;- as.numeric(geocode(&quot;Sentosa&quot;)) %T&gt;% print() ## [1] 103.830321 1.249404 "],
["world-map.html", "World Map", " World Map The data for plotting the World map comes from the maps (Brownrigg, 2014) package. We load the vector data for plotting a world map using map_data(). ds &lt;- map_data(&quot;world&quot;) head(ds) ## long lat group order region subregion ## 1 -69.89912 12.45200 1 1 Aruba &lt;NA&gt; ## 2 -69.89571 12.42300 1 2 Aruba &lt;NA&gt; ## 3 -69.94219 12.43853 1 3 Aruba &lt;NA&gt; ## 4 -70.00415 12.50049 1 4 Aruba &lt;NA&gt; ## 5 -70.06612 12.54697 1 5 Aruba &lt;NA&gt; ## 6 -70.05088 12.59707 1 6 Aruba &lt;NA&gt; It is quite simple to plot the world map using ggplot2 (Wickham and Chang, 2014). p &lt;- ggplot(ds, aes(x=long, y=lat, group=group)) + geom_polygon() p Let us add some colour based on regions. Now there are many regions, so for the same of aesthecity we will turn off the legend. p &lt;- ggplot(ds, aes(x=long, y=lat, group=group, fill=region)) + geom_polygon() + theme(legend.position=&quot;none&quot;) p "],
["understanding-spatial-data.html", "Understanding Spatial Data", " Understanding Spatial Data Spatial data involves a combination of information about locations and geometric features related that best describe the location. The most commonly used formats to store spatial information are Raster and Vector. A Raster format is a type of digital image represented by grids which can be reduced and enlarged. They are made up of a matrix of pixels with each pixel representing an area within the spatial object. A Vector format consists of geometric shapes organized in the form of shapefiles. A shapefile consist of three files under the extensions .shp, .shx and .dbf which contain the features, indices of shapes and attributes respectively. Plotting Raster Data We shall use the getData function in the dismo package to obtain altitude data of Australia and plot them. aust &lt;- getData(&#39;alt&#39;, country=&#39;Australia&#39;, mask=TRUE) ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files plot(aust) ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files Plotting Shapefiles Let us visualize the streets and places of Singapore. We can obtain the data from data.gov.sg . We shall project it on top of a base map obtained from OpenStreetMap. shpfile &lt;- readOGR(dsn=&#39;data/street-and-places/&#39;, &#39;StreetsandPlaces&#39;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;data/street-and-places/&quot;, layer: &quot;StreetsandPlaces&quot; ## with 369 features ## It has 18 fields ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files head(coordinates(shpfile), 5) ## coords.x1 coords.x2 ## [1,] 28640.40 29320.77 ## [2,] 29429.83 28548.69 ## [3,] 29224.01 28360.38 ## [4,] 29827.20 29664.26 ## [5,] 28451.00 29451.78 It is observed that the projection system is different than the base map. So we shall transform the projection in to Web Mercator. crsobj &lt;- CRS(&quot;+proj=longlat +datum=WGS84&quot;) # Web Mercator projection system ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files shpfile.t &lt;- spTransform(shpfile, crsobj) # Applying projection transformation ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files ## NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files df &lt;- as.data.frame(coordinates(shpfile.t)) # Converting to a data frame df$Name &lt;- shpfile$NAME # Adding names of the location df$Longitude &lt;- df$coords.x1 df$Latitude &lt;- df$coords.x2 df$coords.x1 &lt;- NULL df$coords.x2 &lt;- NULL head(df, 5) ## Name Longitude Latitude ## 1 Outram Road 103.8391 1.281441 ## 2 Parsi Road 103.8462 1.274459 ## 3 Keppel Road 103.8443 1.272756 ## 4 Philip Street 103.8497 1.284547 ## 5 Pearl&#39;s Hill Prison 103.8374 1.282626 Now it looks fine to be projected on top of the base map. sgmap &lt;- get_map(location=&quot;Singapore&quot;, zoom=11, maptype=&quot;roadmap&quot;, source=&quot;google&quot;) # Using Osm base map of Singapore ## Source : https://maps.googleapis.com/maps/api/staticmap?center=Singapore&amp;zoom=11&amp;size=640x640&amp;scale=2&amp;maptype=roadmap&amp;language=en-EN ## Source : https://maps.googleapis.com/maps/api/geocode/json?address=Singapore ggmap(sgmap) + geom_point(data=df, aes(x=Longitude, y=Latitude), color=&#39;orange&#39;, size=1) "],
["annotating-location-on-a-map.html", "Annotating Location on a Map", " Annotating Location on a Map We shall plot the location of Sentosa and annotate it with a location landmark and text. addr &lt;- &#39;Sentosa&#39; loc &lt;- as.numeric(geocode(addr)) map &lt;- get_map(loc, zoom=15, maptype=&#39;satellite&#39;, source=&#39;google&#39;) lbl &lt;- data.frame(lon=loc[1], lat=loc[2], text=addr) ggmap(map) + geom_text(data=lbl, aes(x=lon, y=lat, label=text), colour=&#39;blue&#39;, vjust=1.5) + geom_point(data=lbl, aes(x=lon, y=lat), colour=&#39;red&#39;, size=3) "],
["plotting-polygons-and-heatmaps.html", "Plotting Polygons and HeatMaps", " Plotting Polygons and HeatMaps This example comes from the help page for map data() from ggplot2 (Wickham and Chang, 2014). It shows the number of assaults per murder in each US state, though it is quite easy to modify the code to display various statistics from the data. First we take a copy of the USArrests dataset and lowercase the variables and the state names to make the matching across di erent datasets uniform. arrests &lt;- USArrests names(arrests) &lt;- tolower(names(arrests)) arrests$region &lt;- tolower(rownames(USArrests)) head(arrests) ## murder assault urbanpop rape region ## Alabama 13.2 236 58 21.2 alabama ## Alaska 10.0 263 48 44.5 alaska ## Arizona 8.1 294 80 31.0 arizona ## Arkansas 8.8 190 50 19.5 arkansas ## California 9.0 276 91 40.6 california ## Colorado 7.9 204 78 38.7 colorado ## murder assault urbanpop rape region ## Alabama 13.2 236 58 21.2 alabama ## Alaska 10.0 263 48 44.5 alaska ## Arizona 8.1 294 80 31.0 arizona Then we merge the statistics with the spatial data in readiness for mapping. states &lt;- map_data(&quot;state&quot;) ds &lt;- merge(states, arrests, sort=FALSE, by=&quot;region&quot;) head(ds) ## region long lat group order subregion murder assault urbanpop ## 1 alabama -87.46201 30.38968 1 1 &lt;NA&gt; 13.2 236 58 ## 2 alabama -87.48493 30.37249 1 2 &lt;NA&gt; 13.2 236 58 ## 3 alabama -87.95475 30.24644 1 13 &lt;NA&gt; 13.2 236 58 ## 4 alabama -88.00632 30.24071 1 14 &lt;NA&gt; 13.2 236 58 ## 5 alabama -88.01778 30.25217 1 15 &lt;NA&gt; 13.2 236 58 ## 6 alabama -87.52503 30.37249 1 3 &lt;NA&gt; 13.2 236 58 ## rape ## 1 21.2 ## 2 21.2 ## 3 21.2 ## 4 21.2 ## 5 21.2 ## 6 21.2 Once we have the data ready, plotting it simply requires nominating the dataset, and identifying the x and y as long and lat respectively. We also need to identify the grouping, which is by state, and so the fill is then specified for each state to indicate the statistic of interest. g &lt;- ggplot(ds, aes(x=long, y=lat, group=group, fill=assault/murder)) + geom_polygon() g + xlab(&#39;Logitude&#39;) + ylab(&#39;Latitude&#39;) "],
["interactive-maps-with-leaflet.html", "Interactive Maps with Leaflet", " Interactive Maps with Leaflet Earlier we saw a static visualization of places in Singapore now we can explore an interactive version of the same using leaflet. library(leaflet) hundred.places &lt;- df[1:100,] hundred.places.viz &lt;- leaflet() %&gt;% addTiles() %&gt;% addMarkers(data=hundred.places, lng=hundred.places$Longitude, lat=hundred.places$Latitude) hundred.places.viz -->"]
]
