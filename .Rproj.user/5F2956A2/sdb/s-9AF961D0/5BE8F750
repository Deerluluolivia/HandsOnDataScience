{
    "collab_server" : "",
    "contents" : "---\nknit: \"bookdown::preview_chapter\"\n---\n\n# Strings Manipulation\n\nIn this module we introduce to tools available in R for handling and processing strings.\nThe required packages for this module include:\n\n```{r results='hide',message=FALSE}\nlibrary(rattle) # The weather dataset.\nlibrary(stringr) # Pre-eminent package for string handling.\n```\n## String Concatenation\n\nLet us start with the simplest of string operations - concatenation two strings. The **cat()** function concatenates objects and could also print them to screen or to a file. By default it converts even numeric and other complex objects into character type and then concatenates . Alternatively we can use the **paste()** function to concatenate and print the values to screen. The **str_c()** function is similar to the paste() function but the default separator is white space and it ignores NULL characters. \n\n```{r,eval=TRUE}\ncat(\"hello\",\"world\",sep=\"\\t\")\n\nx <- 123 #Using numeric values with cat\ncat (\"hello\",x,sep=\"\\t\")\n\npaste(\"hello\",\"world\", sep=\"\\t\") #usage paste function\n\nstr_c('hello',NULL,'world') # str_c with null characters\n```\n\n## String Length \n\nThe **nchar()** function in the base package is used to measure the typical length of the string. The **str_length()** package could also be used to measure string lengths. In comparisson the str\\_length() package handles NA characters more accurately as nchar(NA) returns 2 while str\\_length() returns NA. The other advantage of str_length() over nchar() is its ability to handle factors robustly.\n\n```{r,error=T}\n\nnchar('hello world') #nchar functionality\nnchar(NA)\n\nstr_length('hello world') #str_length from stringr package\nstr_length(NA)\n\nfactor_example = factor(c(1, 1, 0,0), labels = c(\"success\", \"fail\"))\n\n#Handling factors str_length\nstr_length(factor_example)\n\n#Handling factors nchar\nnchar(factor_example)\n```\n\n## Case Conversion\n\nOften during data transformations strings have to be converted from one case to the other. These simple transformations could be achieved by **tolower()** and **toupper()** functions. The **casefolding()** function could also be used as a wrapper to the two functions.\n\n```{r,message=F}\n\n#Conversion to upper case\ntoupper('string manipulation')\n\n#Conversion to lower case\ntolower('STRING MANIPULATION')\n\n#casefold to upper\ncasefold('string manipulation',upper=TRUE)\n```\n\n## Substring Operation \n\nFinding substrings are one of the most common string manipulation operations. The **substr()** could be used to extract, replace parts of the string. The **substring()** functions performs the same operations on a character vector. \n\n\n```{r}\n\n#Exctraction strings\nsubstr('string manipulation',3,6)\n\n#Replacing strings with substr\ns <- 'string manipulation'\nsubstr(s,3,6) <- 'RING'\ns\n\n#Extraction from character vectors using substring\nx <- c('abcd','aabcb','babcc','cabcd')\nsubstring(x,2,last = 4)\n\n#Replacing in character vector using substring\nsubstring(x,2,last=4) <- 'AB'\nx\n```\n\nThe stringr package offers **str_sub()** which is a equivalent of substring(). The str\\_sub() function handles negative values even more robustly than the substring() function.\n\n```{r}\ny = c(\"string\", \"manipulation\", \"always\", \"fascinating\")\n\n# substring function using negative indices\nsubstring(y,first = -4,last = -1)\n# str_sub handles negative indices\nstr_sub(y , start = -4, end = -1)\n\n#String replacement using str_sub\nstr_sub(y,start=-4,end=-1) <- 'RING'\ny\n```\n\n## String trimming and padding \n\nOne of the major challenges of string parsing is handline additional whitespaces in words. Often additional widespaces are present on the left, right or both sides of the word. The **str_trim** function offers an effective way to get rid of these whitespaces.\n\n```{r}\n\nwhitespace.vector <- c('  abc','def   ','     ghi       ')\n#trimming on left sides\nstr_trim(whitespace.vector,side = 'left')\n#trimming on right sides\nstr_trim(whitespace.vector,side = 'right')\n#trimming on both sides\nstr_trim(whitespace.vector,side = 'both')\n```\n\nConversely we could also pad a string with additional characters for a defined width using the **str_pad()**\nfunction. The default padding character is a space.\n\n```{r}\n#Left padding\nstr_pad('abc',width=7,side=\"left\")\n\n#Right padding\nstr_pad('abc',width=7,side=\"right\")\n\n#Padding other characters\nstr_pad('abc',width=7,side=\"both\",pad=\"#\")\n```\n\n## String Wrapping\n\nSometimes text have to be manipulated to neat paragraphs of defined width. The **str_wrap()** function could be used to format the text into defined paragraphs of specific width.\n\n```{r}\n\nsome_text = 'All the Worlds a stage, All men are merely players'\ncat(str_wrap(some_text,width=25))\n```\n\n## Extracting Words\n\nLet us complete this chapter with the simple **word()** function which extract words from a sentence. We specify the positions of the word to be extracted from the setence. The default separator value is space.\n\n```{r}\n#Extracting the first two words of a character vector\nsome.text <- c('The quick brown fox','jumps on the brown dog')\nword(some.text,start = 1,end=2)\n#extracting all but the last word\nword(some.text,start=1,end=-2)\n```\n\n\n\n",
    "created" : 1467774710475.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3897969803",
    "id" : "5BE8F750",
    "lastKnownWriteTime" : 1467865660,
    "last_content_update" : 1467865660436,
    "path" : "~/Work/Study/R/handsondatascience/hds_bookdown/StringsO.Rmd",
    "project_path" : "StringsO.Rmd",
    "properties" : {
        "marks" : "<:0,0\n>:0,0",
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}